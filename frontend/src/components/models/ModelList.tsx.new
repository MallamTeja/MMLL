import React, { useState, useEffect, useCallback, useRef } from 'react';
import { 
  Box, 
  Text, 
  Badge, 
  Button, 
  useDisclosure,
  IconButton,
  Tooltip,
  useToast,
  Spinner,
  Flex,
  Tabs, 
  TabList, 
  TabPanels, 
  Tab, 
  TabPanel,
  VStack,
  HStack,
  Divider,
  Progress as ChakraProgress,
  Table,
  Thead,
  Tbody,
  Tr,
  Th,
  Td,
  TableContainer,
  Select,
  Heading,
  Modal,
  ModalOverlay,
  ModalContent,
  ModalHeader,
  ModalBody,
  ModalCloseButton,
  ModalFooter,
  useColorMode,
  SimpleGrid,
  Code,
  Link,
  Tag,
  TagLabel,
  TagLeftIcon,
  Wrap,
  WrapItem
} from '@chakra-ui/react';
import { 
  FiEye, 
  FiTrash2, 
  FiDownload, 
  FiUpload, 
  FiBarChart2, 
  FiClock, 
  FiAlertTriangle, 
  FiInfo, 
  FiCpu,
  FiLayers,
  FiCheckCircle,
  FiAlertCircle,
  FiPlay,
  FiPause,
  FiRefreshCw,
  FiExternalLink,
  FiCode
} from 'react-icons/fi';
import { 
  LineChart, 
  Line, 
  BarChart, 
  Bar, 
  XAxis, 
  YAxis, 
  CartesianGrid, 
  Tooltip as RechartsTooltip, 
  Legend, 
  ResponsiveContainer, 
  Cell 
} from 'recharts';

interface ModelMetrics {
  test_mae?: number;
  test_loss?: number;
  training_history?: {
    loss: number[];
    val_loss: number[];
    mae: number[];
    val_mae: number[];
  };
  precision?: number;
  recall?: number;
  f1Score?: number;
  accuracy?: number;
  trainingSamples?: number;
  validationSamples?: number;
  trainingTime?: number;
  lastTrained?: string;
}

interface ModelVersion {
  id: string;
  version: string;
  created_at: string;
  metrics: ModelMetrics;
  status: 'active' | 'archived';
  description?: string;
  createdAt?: string;
}

interface Model {
  id: string;
  name: string;
  model_type: string;
  metrics: ModelMetrics;
  created_at: string;
  status: 'active' | 'training' | 'error' | 'idle';
  versions?: ModelVersion[];
  file_path?: string;
}

interface ModelListProps {
  machines: Array<{ id: number; name: string }>;
}

interface TrainingProgress {
  modelId: string;
  progress: number;
  status: 'training' | 'completed' | 'failed';
  message?: string;
  metrics?: ModelMetrics;
}

const COLORS = ['#0088FE', '#00C49F', '#FFBB28', '#FF8042', '#8884d8'];

const ModelStatusBadge = ({ status }: { status: string }) => {
  const statusColors = {
    active: 'green',
    training: 'blue',
    deployed: 'purple',
    failed: 'red',
    archived: 'gray',
    idle: 'gray',
    error: 'red'
  };

  const statusIcons = {
    active: FiCheckCircle,
    training: FiClock,
    deployed: FiCpu,
    failed: FiAlertCircle,
    archived: FiLayers,
    idle: FiPause,
    error: FiAlertTriangle
  };

  const Icon = statusIcons[status as keyof typeof statusIcons] || FiInfo;
  const colorScheme = statusColors[status as keyof typeof statusColors] || 'gray';

  return (
    <Tag colorScheme={colorScheme} size="sm" borderRadius="full">
      <TagLeftIcon as={Icon} />
      <TagLabel textTransform="capitalize">{status}</TagLabel>
    </Tag>
  );
};

const ModelMetricsCard = ({ metrics }: { metrics: ModelMetrics }) => {
  if (!metrics) {
    return (
      <Box p={4} borderWidth={1} borderRadius="md">
        <Text>No metrics available</Text>
      </Box>
    );
  }

  const chartData = [
    { name: 'Precision', value: (metrics.precision || 0) * 100 },
    { name: 'Recall', value: (metrics.recall || 0) * 100 },
    { name: 'F1 Score', value: (metrics.f1Score || 0) * 100 },
    { name: 'Accuracy', value: (metrics.accuracy || 0) * 100 },
  ].filter(item => !isNaN(item.value));

  return (
    <Box p={4} borderWidth={1} borderRadius="md">
      <SimpleGrid columns={{ base: 1, md: 2 }} spacing={4}>
        <Box>
          <Text fontWeight="bold" mb={2}>Training Metrics</Text>
          {metrics.trainingSamples && (
            <Text>Training Samples: {metrics.trainingSamples.toLocaleString()}</Text>
          )}
          {metrics.validationSamples && (
            <Text>Validation Samples: {metrics.validationSamples.toLocaleString()}</Text>
          )}
          {metrics.trainingTime && (
            <Text>Training Time: {metrics.trainingTime.toFixed(2)}s</Text>
          )}
          {metrics.lastTrained && (
            <Text>Last Trained: {new Date(metrics.lastTrained).toLocaleString()}</Text>
          )}
        </Box>
        {chartData.length > 0 && (
          <Box>
            <Text fontWeight="bold" mb={2}>Model Performance</Text>
            <ResponsiveContainer width="100%" height={200}>
              <BarChart data={chartData}>
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="name" />
                <YAxis domain={[0, 100]} />
                <RechartsTooltip formatter={(value: number) => [`${value.toFixed(2)}%`, 'Score']} />
                <Bar dataKey="value" fill="#8884d8">
                  {chartData.map((entry, index) => (
                    <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />
                  ))}
                </Bar>
              </BarChart>
            </ResponsiveContainer>
          </Box>
        )}
      </SimpleGrid>
    </Box>
  );
};

const ModelList: React.FC<ModelListProps> = ({ machines }) => {
  // State management
  const [models, setModels] = useState<Model[]>([]);
  const [selectedModel, setSelectedModel] = useState<Model | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [isDeleting, setIsDeleting] = useState(false);
  const [activeTab, setActiveTab] = useState(0);
  const [trainingProgress, setTrainingProgress] = useState<Record<string, TrainingProgress>>({});
  
  // Refs and hooks
  const cancelRef = useRef<HTMLButtonElement>(null);
  const toast = useToast();
  const { colorMode } = useColorMode();
  const bgColor = colorMode === 'dark' ? 'gray.800' : 'white';
  const borderColor = colorMode === 'dark' ? 'gray.700' : 'gray.200';

  // Modal controls
  const { isOpen: isDetailsOpen, onOpen: onDetailsOpen, onClose: onDetailsClose } = useDisclosure();
  const { isOpen: isDeleteOpen, onOpen: onDeleteOpen, onClose: onDeleteClose } = useDisclosure();
  const { isOpen: isDeployOpen, onOpen: onDeployOpen, onClose: onDeployClose } = useDisclosure();
  const [selectedModelId, setSelectedModelId] = useState<string | null>(null);

  // Fetch models on component mount
  useEffect(() => {
    fetchModels();
  }, []);

  // Fetch models from API
  const fetchModels = useCallback(async () => {
    try {
      setIsLoading(true);
      // Replace with your actual API call
      // const response = await axios.get('/api/models');
      // setModels(response.data);
      
      // Mock data for now
      const mockModels: Model[] = [
        {
          id: '1',
          name: 'LSTM Model',
          model_type: 'LSTM',
          status: 'active',
          created_at: new Date().toISOString(),
          metrics: {
            test_mae: 0.05,
            test_loss: 0.1,
            precision: 0.92,
            recall: 0.89,
            f1Score: 0.90,
            accuracy: 0.91,
            trainingSamples: 1000,
            validationSamples: 200,
            trainingTime: 120.5,
            lastTrained: new Date().toISOString(),
            training_history: {
              loss: [0.5, 0.3, 0.2, 0.15, 0.1],
              val_loss: [0.6, 0.35, 0.25, 0.18, 0.12],
              mae: [0.4, 0.25, 0.18, 0.12, 0.08],
              val_mae: [0.45, 0.28, 0.2, 0.15, 0.1]
            }
          },
          versions: [
            {
              id: 'v1',
              version: '1.0.0',
              created_at: new Date().toISOString(),
              status: 'active',
              metrics: {}
            }
          ]
        }
      ];
      
      setModels(mockModels);
    } catch (error) {
      console.error('Error fetching models:', error);
      toast({
        title: 'Error',
        description: 'Failed to fetch models',
        status: 'error',
        duration: 5000,
        isClosable: true,
      });
    } finally {
      setIsLoading(false);
    }
  }, [toast]);

  // Handle viewing model details
  const handleViewDetails = useCallback((model: Model) => {
    setSelectedModel(model);
    onDetailsOpen();
  }, [onDetailsOpen]);

  // Handle delete button click
  const handleDeleteClick = useCallback((model: Model) => {
    setSelectedModel(model);
    onDeleteOpen();
  }, [onDeleteOpen]);

  // Handle model deletion
  const handleDelete = useCallback(async () => {
    if (!selectedModel) return;
    
    try {
      setIsDeleting(true);
      // Replace with your actual API call
      // await axios.delete(`/api/models/${selectedModel.id}`);
      
      // Update local state
      setModels(prev => prev.filter(m => m.id !== selectedModel.id));
      
      toast({
        title: 'Success',
        description: 'Model deleted successfully',
        status: 'success',
        duration: 3000,
        isClosable: true,
      });
      
      onDeleteClose();
    } catch (error) {
      console.error('Error deleting model:', error);
      toast({
        title: 'Error',
        description: 'Failed to delete model',
        status: 'error',
        duration: 5000,
        isClosable: true,
      });
    } finally {
      setIsDeleting(false);
    }
  }, [selectedModel, onDeleteClose, toast]);

  // Render model metrics
  const renderModelMetrics = useCallback((metrics: ModelMetrics) => {
    if (!metrics) {
      return (
        <Text fontSize="sm" color="gray.500" fontStyle="italic">
          No metrics available
        </Text>
      );
    }

    return <ModelMetricsCard metrics={metrics} />;
  }, []);

  // Render training progress
  const renderTrainingProgress = useCallback((model: Model) => {
    const progress = trainingProgress[model.id];
    if (!progress) return null;

    return (
      <Box mt={2}>
        <Text fontSize="sm" mb={1}>
          {progress.status === 'training' ? 'Training in progress' : 
           progress.status === 'completed' ? 'Training completed' : 'Training failed'}
        </Text>
        <ChakraProgress 
          value={progress.progress} 
          colorScheme={progress.status === 'completed' ? 'green' : progress.status === 'failed' ? 'red' : 'blue'}
          size="sm" 
          borderRadius="full"
        />
        {progress.message && (
          <Text fontSize="xs" color="gray.500" mt={1}>
            {progress.message}
          </Text>
        )}
      </Box>
    );
  }, [trainingProgress]);

  return (
    <Box>
      <Box mb={4} display="flex" justifyContent="space-between" alignItems="center">
        <Text fontSize="xl" fontWeight="bold">Trained Models</Text>
        <Button colorScheme="blue" size="sm">
          Train New Model
        </Button>
      </Box>

      {isLoading ? (
        <Flex justify="center" align="center" minH="200px">
          <Spinner size="xl" />
        </Flex>
      ) : models.length === 0 ? (
        <Box textAlign="center" py={10}>
          <Text color="gray.500">No models found. Train a new model to get started.</Text>
          <Button mt={4} colorScheme="blue">Train Model</Button>
        </Box>
      ) : (
        <TableContainer>
          <Table variant="simple">
            <Thead>
              <Tr>
                <Th>Name</Th>
                <Th>Type</Th>
                <Th>Status</Th>
                <Th>Created</Th>
                <Th>Metrics</Th>
                <Th>Actions</Th>
              </Tr>
            </Thead>
            <Tbody>
              {models.map((model) => (
                <Tr key={model.id}>
                  <Td fontWeight="medium">{model.name}</Td>
                  <Td>{model.model_type}</Td>
                  <Td>
                    <ModelStatusBadge status={model.status} />
                  </Td>
                  <Td>{new Date(model.created_at).toLocaleDateString()}</Td>
                  <Td>
                    <Text fontSize="sm">
                      MAE: {model.metrics?.test_mae?.toFixed(4) || 'N/A'}
                    </Text>
                    <Text fontSize="sm">
                      Loss: {model.metrics?.test_loss?.toFixed(4) || 'N/A'}
                    </Text>
                  </Td>
                  <Td>
                    <HStack spacing={2}>
                      <Tooltip label="View Details">
                        <IconButton
                          aria-label="View details"
                          icon={<FiEye />}
                          size="sm"
                          onClick={() => handleViewDetails(model)}
                        />
                      </Tooltip>
                      <Tooltip label="Download Model">
                        <IconButton
                          aria-label="Download model"
                          icon={<FiDownload />}
                          size="sm"
                          // onClick={() => handleDownloadModel(model.id)}
                        />
                      </Tooltip>
                      <Tooltip label="Delete Model">
                        <IconButton
                          aria-label="Delete model"
                          icon={<FiTrash2 />}
                          size="sm"
                          colorScheme="red"
                          variant="ghost"
                          onClick={() => handleDeleteClick(model)}
                        />
                      </Tooltip>
                    </HStack>
                    {renderTrainingProgress(model)}
                  </Td>
                </Tr>
              ))}
            </Tbody>
          </Table>
        </TableContainer>
      )}

      {/* Model Details Modal */}
      <Modal isOpen={isDetailsOpen} onClose={onDetailsClose} size="xl">
        <ModalOverlay />
        <ModalContent>
          <ModalHeader>Model Details</ModalHeader>
          <ModalCloseButton />
          <ModalBody>
            {selectedModel && (
              <VStack align="stretch" spacing={4}>
                <Box>
                  <Text fontWeight="bold">Name</Text>
                  <Text>{selectedModel.name}</Text>
                </Box>
                <Box>
                  <Text fontWeight="bold">Type</Text>
                  <Text>{selectedModel.model_type}</Text>
                </Box>
                <Box>
                  <Text fontWeight="bold">Status</Text>
                  <ModelStatusBadge status={selectedModel.status} />
                </Box>
                <Box>
                  <Text fontWeight="bold">Created</Text>
                  <Text>{new Date(selectedModel.created_at).toLocaleString()}</Text>
                </Box>
                <Box>
                  <Text fontWeight="bold" mb={2}>Metrics</Text>
                  {renderModelMetrics(selectedModel.metrics)}
                </Box>
                {selectedModel.versions && selectedModel.versions.length > 0 && (
                  <Box>
                    <Text fontWeight="bold" mb={2}>Versions</Text>
                    <VStack align="stretch" spacing={2}>
                      {selectedModel.versions.map(version => (
                        <Box key={version.id} p={3} borderWidth={1} borderRadius="md">
                          <Text fontWeight="medium">Version: {version.version}</Text>
                          <Text fontSize="sm" color="gray.500">
                            Created: {new Date(version.created_at).toLocaleString()}
                          </Text>
                          <Text fontSize="sm" color="gray.500">
                            Status: {version.status}
                          </Text>
                        </Box>
                      ))}
                    </VStack>
                  </Box>
                )}
              </VStack>
            )}
          </ModalBody>
          <ModalFooter>
            <Button colorScheme="blue" mr={3} onClick={onDetailsClose}>
              Close
            </Button>
          </ModalFooter>
        </ModalContent>
      </Modal>

      {/* Delete Confirmation Modal */}
      <Modal isOpen={isDeleteOpen} onClose={onDeleteClose}>
        <ModalOverlay />
        <ModalContent>
          <ModalHeader>Delete Model</ModalHeader>
          <ModalCloseButton />
          <ModalBody>
            <Text>Are you sure you want to delete this model? This action cannot be undone.</Text>
          </ModalBody>
          <ModalFooter>
            <Button 
              ref={cancelRef} 
              onClick={onDeleteClose}
              isDisabled={isDeleting}
              mr={3}
            >
              Cancel
            </Button>
            <Button 
              colorScheme="red" 
              onClick={handleDelete}
              isLoading={isDeleting}
              loadingText="Deleting..."
            >
              Delete
            </Button>
          </ModalFooter>
        </ModalContent>
      </Modal>
    </Box>
  );
};

export default ModelList;
